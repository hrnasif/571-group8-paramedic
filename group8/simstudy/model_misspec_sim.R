#!/usr/local/bin/Rscript

# model misspecification simulation (model_misspec_sim.R)
# varying data-generating mechanisms (models for mu, e, V, W)

## load required libraries
library("methods")
#library("StanHeaders", lib.loc = "/home/bwillia2/R/x86_64-pc-linux-gnu-library/3.5")
library("rstan")
library("MASS")
library("argparse")
# devtools::install("statdivlab/paramedic@v0.0.3.900")
library("paramedic")
library("tibble")
library("dplyr")
library("Cairo")

## grab in the job id
job_id <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))

## load in required functions
if (!is.na(Sys.getenv("RSTUDIO", unset = NA))) { # if running locally
    source("data_gen_funcs.R")
    source("data_generator.R")
    #source("naive_qpcr_estimator.R")
    job_id <- 10
} else {
    source("data_gen_funcs.R")
    source("data_generator.R")
    source("naive_qpcr_estimator.R")
}

## set up dynamic simulation arguments
parser <- ArgumentParser()
parser$add_argument("--sim-name", default = "misspec-normal-normal-negbin-mult", help = "name of the simulation")
parser$add_argument("--stan-model", default = "../stan/predict_qpcr.stan",
                    help = "Which Stan model file to use.")
parser$add_argument("--N_subj", type = "double", default = 5, help = "Number of subjects")
parser$add_argument("--N_samp", type = "double", default = 10, help = "Samples per subject")
parser$add_argument("--q", type = "double", default = 10, help = "how many taxa do we have?")
parser$add_argument("--q_obs", type = "double", default = 7, help = "how many taxa do we have qPCR measured on?")
parser$add_argument("--corr_within", type = "double", default = F, help = "choose whether within subject correlations are considered")
parser$add_argument("--sigma_epsilon", default = "random", help = "array for subject-specific error standard deviations")
parser$add_argument("--n-chains", type = "double", default = 1, help = "number of chains for MCMC")
parser$add_argument("--iter", type = "double", default = 100, help = "number of iterations per chain")
parser$add_argument("--warmup", type = "double", default = 50, help = "number of warmup iterations per chain")
parser$add_argument("--B", type = "double", default = 50, help = "total number of MC reps per q, q^obs")
parser$add_argument("--adapt-delta", type = "double", default = 0.85, help = "adapt_delta, for Stan fitting")
parser$add_argument("--max-treedepth", type = "integer", default = 15, help = "max_treedepth, for Stan fitting")
parser$add_argument("--m-min", type = "integer", default = 10000, help = "min M (reads)")
parser$add_argument("--m-max", type = "integer", default = 100000, help = "max M (reads)")
parser$add_argument("--use-most-abundant", type = "integer", default = 1, help = "use q^obs most abundant taxa or not")
args <- parser$parse_args()

if (args$sigma_epsilon == "random") {
    args$sigma_epsilon <- rnorm(args$N_subj, mean=0, sd=1)^2
}

# if (!is.na(Sys.getenv("RSTUDIO", unset = NA))) { # if running locally
#     args$iter <- 100
#     args$warmup <- 50
#     args$adapt_delta <- 0.85
#     args$max_treedepth <- 15
#     args$n_chains <- 1
#     args$q <- 40
#     args$q_obs <- 7
#     args$N <- 50
#     args$sim_name <- "misspec-normal-normal-negbin-mult"
# }
print(paste0("Running sim ", args$sim_name, " with q = ", args$q, "; q_obs = ", args$q_obs, "; N = ", args$N_subj*args$N_samp, "."))
print(paste0("Stan parameters: adapt_delta = ", args$adapt_delta, "; treedepth = ", args$max_treedepth, "; num. burnin iter = ", args$warmup, "; num. total iter = ", args$iter, "; number of chains = ", args$n_chains))

# ----------------------------------------------------------
# set up static simulation arguments
# ----------------------------------------------------------
# get mu and e distributions
get_mu_e_distn <- function(sim_name) {
    split_str <- unlist(strsplit(sim_name, "-", fixed = TRUE))
    mu_distn <- split_str[2]
    e_distn <- split_str[3]
    v_distn <- split_str[4]
    w_distn <- split_str[5]
    return(list(mu = mu_distn, e = e_distn, v = v_distn, w = w_distn))
}
distns <- get_mu_e_distn(args$sim_name)
set.seed(4747)
if (grepl("normal", distns$mu)) {
    # hyperparameter controlling covariance of mus (for normal data)
    Sigma <- diag(1, nrow = args$q, ncol = args$q)
    # hyperparameter controlling mean of mus (for normal data)
    beta_init <- rnorm(args$q, 0, sqrt(50))
    beta <- beta_init[order(beta_init, decreasing = TRUE)][1:args$q]
} else if (grepl("gamma", distns$mu)) {
    # hyperparameter controlling shape of mu distribution
    alpha_init <- rgamma(args$q, .1, 1e-4)
    beta <- alpha_init[order(alpha_init, decreasing = TRUE)]
    # hyperparameter controlling rate of mu distribution
    Sigma <- rep(0.5, args$q)
} else {
    # degrees of freedom
    beta_init <- runif(args$q, 0, 1e2)
    beta <- beta_init[order(beta_init, decreasing = TRUE)]
    Sigma <- rep(2, args$q)
}
if (grepl("normal", distns$e)) {
    hyper_sigma <- 1
} else if (grepl("gamma", distns$e)) {
    hyper_sigma <- 0.5
} else {
    hyper_sigma <- 4
}

options(mc.cores = parallel::detectCores())

# get the random number seed
num_models <- 4
seed_vec <- 1:(args$B*num_models)
samp_seed_vec <- sample(seed_vec)

# set the seed
all_sim_combos <- expand.grid(mu_dist = c("gamma", "halft", "normal"), e_dist = c("gamma", "halft", "normal"), stringsAsFactors = FALSE) 
# scramble the rows so that they match the original ones
all_sim_combos <- all_sim_combos[c(1, 2, 4, 5, 3, 6, 7, 8, 9), ]
all_sim_combos$v_dist <- "poisson"
all_sim_combos$w_dist <- "mult"
last_combos <- data.frame(mu_dist = "normal", e_dist = "normal", 
                          v_dist = c("poisson", "negbin", "negbin"), 
                          w_dist = c("dirimult", "mult", "dirimult"))
final_sim_combos <- rbind.data.frame(all_sim_combos, last_combos)
sim_names <- c(paste0("misspec-", apply(final_sim_combos[-9, ], 1, function(x) paste(x, collapse = "-"))),
               paste0("spec-", paste(final_sim_combos[9, ], collapse = "-")))[c(1:8, 12, 9:11)]
print(sim_names)
current_seed <- samp_seed_vec[job_id] + 10 * args$N_subj*args$N_samp + 1000 * which(args$sim_name == sim_names)
print(paste0("Current seed: ", current_seed))
set.seed(current_seed)

## create the data
dataset_with_truth <- data_generator(N_subj = args$N_subj, N_samp = args$N_samp, num_taxa = args$q, 
                                     num_qpcr = args$q_obs, seed = current_seed, 
                                     hyper_mean_mu = beta, hyper_cov_mu = Sigma, 
                                     hyper_sigma = hyper_sigma, corr_within = args$corr_within,
                                     hyper_sigma_epsilon = args$sigma_epsilon,
                                     hyper_m_min = args$m_min, hyper_m_max = args$m_max,
                                     use_most_abundant = args$use_most_abundant,
                                     mu_dist = distns$mu, e_dist = distns$e,
                                     v_dist = distns$v, w_dist = distns$w)
dataset <- dataset_with_truth[(names(dataset_with_truth) %in% c("V", "W", "N", "q", "q_obs"))]
colnames(dataset$W) <- c("subject_id", "time", c(1:args$q))
colnames(dataset$V) <- c("subject_id", "time", c(1:args$q_obs))

# hard-code prior distribution specification for hyperparameters
dataset$sigma_beta <- sqrt(50.0)
dataset$sigma_Sigma <- sqrt(50.0)
dataset$alpha_sigma <- 2
dataset$kappa_sigma <- 1
## create output directory
prefix <- sprintf("%s/n_%s/n_%s/q_%s/q_obs_%s",
                  args$sim_name,
                  args$N_subj,
                  args$N_samp,
                  args$q,
                  args$q_obs)
fast_prefix <- paste0("../sim-data/", prefix)
if (!dir.exists(fast_prefix)) {
    dir.create(fast_prefix, recursive = TRUE)
}

stan_seed <- current_seed

## set up the parameters to save
params_to_save <- c("mu", "e", "beta_0", "Sigma")

# run the model
set.seed(stan_seed)
system.time(mod <- paramedic::run_paramedic(W = dataset$W, V = dataset$V, n_iter = args$iter, n_samp = args$N_samp,
                                            n_burnin = args$warmup, n_chains = args$n_chains, stan_seed = stan_seed,
                                            #params_to_save = params_to_save,
                                            control = list(adapt_delta = args$adapt_delta, max_treedepth = args$max_treedepth),
                                            verbose = FALSE, open_progress = FALSE))

mod_summ <- mod$summary

# # extract samples
# samps <- extract(mod)
# 
## save the output
saveRDS(mod_summ, file = sprintf("%s/%s_mod_jobid_%d_ad_%f_mt_%d_ab_%s.rds",
                                 fast_prefix,
                                 strsplit(strsplit(args$stan_model, "/")[[1]], ".", fixed = TRUE)[[length(strsplit(strsplit(args$stan_model, "/")[[1]], ".", fixed = TRUE))]][1],
                                 job_id,
                                 args$adapt_delta,
                                 args$max_treedepth,
                                 as.character(args$use_most_abundant)))
saveRDS(dataset_with_truth, file = sprintf("%s/%s_data_jobid_%d_ad_%f_mt_%d_ab_%s.rds",
                                           fast_prefix,
                                           strsplit(strsplit(args$stan_model, "/")[[1]], ".", fixed = TRUE)[[length(strsplit(strsplit(args$stan_model, "/")[[1]], ".", fixed = TRUE))]][1],
                                           job_id,
                                           args$adapt_delta,
                                           args$max_treedepth,
                                           as.character(args$use_most_abundant)))
# saveRDS(samps, file = sprintf("%s/%s_samps_jobid_%d_ad_%f_mt_%d_ab_%s.rds",
#                               fast_prefix,
#                               strsplit(strsplit(args$stan_model, "/")[[1]], ".", fixed = TRUE)[[length(strsplit(strsplit(args$stan_model, "/")[[1]], ".", fixed = TRUE))]][1],
#                               job_id,
#                               args$adapt_delta,
#                               args$max_treedepth,
#                               as.character(args$use_most_abundant)))

# trace_plot_nms <- c("mu", "e", "beta_0", "Sigma")
# fig_width <- fig_height <- 2590
# cex <- 1.5
# ## sample 5 participants to check traceplots for
# set.seed(4747)
# samp <- sample(1:args$N, 2)
# taxa_of_interest <- 10
# if (args$q == 20) {
#     taxa_of_interest <- c(taxa_of_interest, 20)
# } else if (args$q == 40) {
#     taxa_of_interest <- c(taxa_of_interest, 20, 40)
# } else {
#     taxa_of_interest <- c(taxa_of_interest, 20, 40, 60)
# }
# 
# trace_plots_dir <- "../trace_plots/"
# if (!dir.exists(trace_plots_dir)) {
#     dir.create(trace_plots_dir, recursive = TRUE)
# }
# for (n in 1:length(trace_plot_nms)) {
#     for (i in taxa_of_interest) {
#         logi <- grepl(trace_plot_nms[n], names(mod)) & !grepl("log", names(mod)) & grepl(i, names(mod))
#         if (trace_plot_nms[n] == "mu") {
#             logi <- grepl(trace_plot_nms[n], names(mod)) & !grepl("log", names(mod)) & grepl(paste0(",", i, "]"), names(mod), fixed = TRUE)
#         }
#         if (trace_plot_nms[n] == "e") {
#             logi <- grepl(trace_plot_nms[n], names(mod)) & !grepl("log", names(mod)) & !grepl("beta", names(mod)) & grepl(paste0("[", i, "]"), names(mod), fixed = TRUE)
#         }
#         if (trace_plot_nms[n] == "mu") {
#             CairoPNG(paste0(trace_plots_dir, "/", args$sim_name, "_run_paramedic", "_par_", trace_plot_nms[n], "_taxon_", i, "_mcid_", job_id, "_q_", args$q, "_q_obs_", args$q_obs, ".png"), width = fig_width, height = fig_height, res = 300, units = "px")
#             plot(traceplot(mod, pars = names(mod)[logi][samp]), cex = cex)
#             dev.off()
#         } else {
#             CairoPNG(paste0(trace_plots_dir, "/", args$sim_name, "_run_paramedic", "_par_", trace_plot_nms[n], "_taxon_", i, "_mcid_", job_id, "_q_", args$q, "_q_obs_", args$q_obs, ".png"), width = fig_width, height = fig_height, res = 300, units = "px")
#             plot(traceplot(mod, pars = names(mod)[logi]), cex = cex)
#             dev.off()
#         }
#     }
# }